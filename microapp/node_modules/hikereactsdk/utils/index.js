// UTIL FUNCTIONS HERE

import { ToastAndroid, Platform, AsyncStorage, NetInfo , StatusBar, StyleSheet, AlertIOS, NativeModules, BackAndroid} from 'react-native';

import theme from 'react-native-theme';
import StatusBarUtils from '../appthemes/StatusBarUtils';

import { HikeAppState, HikeUtils, HikeUPI, HikeSharing, HikeErrorUtils } from '../../hikereactsdk';


var themeProps = [{
  'key': 'chatBgColor',
  'cssProperty': 'backgroundColor',
  'colorProp': 'chatBgColor'
}, {
  'key': 'chatBgColorAsBorder',
  'cssProperty': 'borderColor',
  'colorProp': 'chatBgColor'
}, {
  'key': 'halfBgColor',
  'cssProperty': 'backgroundColor',
  'colorProp': 'halfBgColor'
}, {
  'key': 'cardBackgroundColor',
  'cssProperty': 'backgroundColor',
  'colorProp': 'backgroundColor'
}, {
  'key': 'cardBackgroundColorAsBorder',
  'cssProperty': 'borderColor',
  'colorProp': 'backgroundColor'
}, {
  'key': 'errorColor',
  'cssProperty': 'color',
  'colorProp': 'errorColor'
}, {
  'key': 'errorColorAsBg',
  'cssProperty': 'backgroundColor',
  'colorProp': 'errorColor'
}, {
  'key': 'accentBgColor',
  'cssProperty': 'backgroundColor',
  'colorProp': 'accentColor'
}, {
  'key': 'accentBorderColor',
  'cssProperty': 'borderColor',
  'colorProp': 'accentColor'
}, {
  'key': 'accentTextColor',
  'cssProperty': 'color',
  'colorProp': 'accentColor'
}, {
  'key': 'transBgTextColor',
  'cssProperty': 'color',
  'colorProp': 'transBgColor'
}, {
  'key': 'transBgBackgroundColor',
  'cssProperty': 'backgroundColor',
  'colorProp': 'transBgColor'
}, {
  'key': 'mainColor',
  'cssProperty': 'color',
  'colorProp': 'mainColor'
}, {
  'key': 'mainColorAsBg',
  'cssProperty': 'backgroundColor',
  'colorProp': 'mainColor'
}, {
  'key': 'mainColorAsBorder',
  'cssProperty': 'borderColor',
  'colorProp': 'mainColor'
}, {
  'key': 'secondaryColor',
  'cssProperty': 'color',
  'colorProp': 'secondaryColor'
}, {
  'key': 'secondaryColorAsBg',
  'cssProperty': 'backgroundColor',
  'colorProp': 'secondaryColor'
}, {
  'key': 'secondaryColorBorder',
  'cssProperty': 'borderColor',
  'colorProp': 'secondaryColor'
}, {
  'key': 'tertiaryColor',
  'cssProperty': 'color',
  'colorProp': 'tertiaryColor'
}, {
  'key': 'tertiaryColorAsBg',
  'cssProperty': 'backgroundColor',
  'colorProp': 'tertiaryColor'
}, {
  'key': 'tertiaryColorBorder',
  'cssProperty': 'borderColor',
  'colorProp': 'tertiaryColor'
}, {
  'key': 'hintColorText',
  'cssProperty': 'color',
  'colorProp': 'hintColor'
}, {
  'key': 'hintColorBorder',
  'cssProperty': 'borderColor',
  'colorProp': 'hintColor'
}, {
  'key': 'hintColorAsBg',
  'cssProperty': 'backgroundColor',
  'colorProp': 'hintColor'
}, {
  'key': 'seperatorColor',
  'cssProperty': 'backgroundColor',
  'colorProp': 'seperatorColor'
}, {
  'key': 'seperatorColorBottom',
  'cssProperty': 'borderColor',
  'colorProp': 'separatorColor'
}, {
  'key': 'activeColor',
  'cssProperty': 'backgroundColor',
  'colorProp': 'activeColor'
}, {
  'key': 'chipsFgColor',
  'cssProperty': 'color',
  'colorProp': 'chipsFgColor'
}, {
  'key': 'chipsFgColorAsBackground',
  'cssProperty': 'backgroundColor',
  'colorProp': 'chipsFgColor'
}, {
  'key': 'chipsBgColor',
  'cssProperty': 'backgroundColor',
  'colorProp': 'chipsBgColor'
}, {
  'key': 'sdrSentColor',
  'cssProperty': 'color',
  'colorProp': 'sdrSentColor'
}, {
  'key': 'sdrReceiveColor',
  'cssProperty': 'color',
  'colorProp': 'sdrReceiveColor'
}, {
  'key': 'profileBgColor',
  'cssProperty': 'backgroundColor',
  'colorProp': 'profileBgColor'
}];

export default class utils {

  static showToast(text, type = 'short') {
     if (Platform.OS === 'ios') {
       AlertIOS.alert(
           null,
           text
         );
     } else {
       switch (type) {
         case 'short':
           ToastAndroid.show(text, ToastAndroid.SHORT);
           break;
         case 'long':
           ToastAndroid.show(text, ToastAndroid.LONG);
           break;
       }
     }
   }

   static exitApp() {
     if(Platform.OS === "ios") {
       HikeAppState.exitApp();
     } else {
       BackAndroid.exitApp();
     }
   }

   static hexToDec(hex) {
     return hex.toLowerCase().split('').reduce( (result, ch) =>
      result * 16 + '0123456789abcdefgh'.indexOf(ch), 0);
   }

   static hexToRgbA(hex, opacity){
     var c;
     if(/^#([A-Fa-f0-9]{3}){1,2}$/.test(hex)) {
       c = hex.substring(1).split('');
       if(c.length== 3) {
         c= [c[0], c[0], c[1], c[1], c[2], c[2]];
       }
       c = '0x'+c.join('');
       return 'rgba('+[(c>>16)&255, (c>>8)&255, c&255].join(',')+','+opacity+')';
    }
    throw new Error('Bad Hex');
  }

  static convertThemeColor(color){
    if(!color) {
      return '';
    }

    let output = null;

    if(color[0] === "#"){
      color = color.substring(color.length,1);
    }

    // ARGB CHECK
    if(color.length === 8){

      const opacity = this.hexToDec(color[0]+color[1]);
      const hex = "#"+color[2]+color[3]+color[4]+color[5]+color[6]+color[7];
      output = this.hexToRgbA(hex, opacity)

    }else{
      output = "#"+color;
    }

    return output;

  }

  /***
   * Sets the app themeData
   * @param themeData : themeData passed from app
   * @param extraThemeProps: array of extra props that needs to be set in theme
   *   extraThemeProps = [{ key: 'profileBgColorAsBorder', cssProperty: 'borderColor', colorProp: 'profileBgColor'}]
   *
   */

  static setAppTheme(themeData, extraThemeProps) {
      let themeObject = {};
      try{
        themeObject = JSON.parse(themeData);
      } catch(e) {
        themeObject = themeData;
      }
      const gradientColors = themeObject.gradientColors.split(',');

      let themeColors = {
        gradientColorOne:{
          backgroundColor: gradientColors[0],
        },
        gradientColorTwo:{
          backgroundColor: gradientColors[1],
        },
        gradientColorThree:{
          backgroundColor: gradientColors[2],
        },
        patternAppFillOpacity:{
          opacity: parseFloat(themeObject.patternAppFillOpacity),
        },
        patternAppFillColor:{
          color: this.convertThemeColor(themeObject.patternAppFillColor)
        },
        pattern: themeObject.pattern
      };
      if(extraThemeProps) {
        themeProps = themeProps.concat(extraThemeProps);
      }
      themeProps.forEach((obj) => {
        let color = this.convertThemeColor(themeObject.colorProps[obj.colorProp]);
        if(color) {
          if(!themeColors[obj.key]) {
            themeColors[obj.key] = {};
          }
          themeColors[obj.key][obj.cssProperty] = color;
        }
      });

      theme.add(themeColors);

  }


  static getTintColorForIcon(type){
    switch(type){
      case 'trans':
        return StyleSheet.flatten(theme.styles.transBgBackgroundColor).backgroundColor
        break;

      case 'main':
        return StyleSheet.flatten(theme.styles.mainColor).color
        break;

      case 'accent':
        return StyleSheet.flatten(theme.styles.accentTextColor).color
        break;

      case 'secondary':
        return StyleSheet.flatten(theme.styles.secondaryColor).color
        break;

      case 'tertiary':
        return StyleSheet.flatten(theme.styles.tertiaryColor).color
        break;

      case 'bgColor':
        return StyleSheet.flatten(theme.styles.cardBackgroundColor).color
        break;

      case 'sdrSentColor':
        return StyleSheet.flatten(theme.styles.sdrSentColor).color

    }

  }

  static getThemeColor(colorProperty) {
      return StyleSheet.flatten(theme.styles[colorProperty]).color;
  }

  static getPatternName(nameArray) {
    delete nameArray.includes;
    delete nameArray.repeat;
    nameArray['length'] = Object.keys(nameArray).length;
    return output = Array.prototype.slice.call(nameArray).join("");
  }

  // Check Internet Connection Settings For Platform
  static checkConnectionStatus() {
    return NetInfo.isConnected.fetch()
          .then(isConnected => isConnected);
  }

  static _killNativeLoader() {
    if (Platform.OS === "ios") {
      if(NativeModules.HikeLoaderModule){
        const NativeLoaderModule = NativeModules.HikeLoaderModule;
        NativeLoaderModule.setKillLoaderEvent();
      }
    } else {
      if(NativeModules.NativeLoaderModule){
        const NativeLoaderModule = NativeModules.NativeLoaderModule;
        NativeLoaderModule.setKillLoaderEvent();
      }
    }
  }

  static killNativeLoaderAndSetStatusBarColor(appData) {
    utils._killNativeLoader();
    StatusBarUtils.setStatusBarColor(appData);
  }
}
