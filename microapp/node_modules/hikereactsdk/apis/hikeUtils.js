/**
 * Created by anurag on 21/11/16.
 */

import { NativeModules } from 'react-native';

const HikeUtilsModule = NativeModules.HikeUtilsModule;

/**
 * Hike Utils Module
 */
class HikeUtils {
  /**
   * Log analytics object
   * @param {Object} obj Analytics json to be logged
   */
  static logAnalytics(obj) { HikeUtilsModule.logAnalytics(obj); }
  static logAnalyticsV2(obj) { HikeUtilsModule.logAnalyticsV2(obj); }

  /**
   * Log any message to the xCode/Android Studio console.
   * @param {string} message string that needs to be logged to the console
   */
  static log(message) { console.log(message) }

  /**
   * Delete notification data based on key. If key is not provided, entire notification data is deleted.
   * @param {string} key Key for the notification data to be deleted.
   */
  static deleteNotifData(key) {
    if (key !== undefined && key !== null) {
      HikeUtilsModule.deletePartialNotifData(key);
    } else {
      HikeUtilsModule.deleteAllNotifData();
    }
  }

  /**
   * Open a Microapp with an option to get it from server on device if not present already. This is
   * exposed as a private method since other UIDs of microapps are unknown as of now and this would
   * be replaced by individual Microapp invocation methods once they are.
   *
   * @param {string} mAppId Microapp Id for the Microapp to be opened.
   * @param {object} params Parameters which control microapp opening behavior and data to be passed
   * along to the other microapp.
   * @param {Boolean} params.getIfMissing True if the app has to be downloaded if it is missing on
   * user's device.
   * @param {object} params.passData JSON object that is passed to the microapp being opened.
   * Received as passData in main component props when the Microapp being opened spawns.
   *
   * @returns {Promise} Resolved if Microapp is being successfully opened. Rejected if there is
   * some error when opening a Microapp. For eg. if a Microapp doesn't exist on a user's device or
   * some other error occurs. You can hook into this promise's response to show a loader for eg. or
   * an error toast in case it fails.
   */
  static openMicroapp(mAppUid, params = {}) {
    return HikeUtilsModule.openMicroapp(mAppUid, params);
  }

  /**
   * Called by callee microapp when it is done. This is used to pass back any data to calling microapp.
   * @param {object} [params] Params that need to be passed to calling microapp.
   */
  static microappDone(params = {}) {
    HikeUtilsModule.microappDone(params);
  }


  static startContactChooser() {
    return HikeUtilsModule.startContactChooser();
  }
  static startContactChooserGroups(params = {}) {
    return HikeUtilsModule.startContactChooserGroups();

  }

  static forwardToChat(json, hikeMessage) {
    return HikeUtilsModule.forwardToChat(json, hikeMessage);
  }

  static updateLastMessage(message) {
    return HikeUtilsModule.updateLastMessage(message);
  }

  static shareScreenWithLink(isInternalShare, backLinkData) {
    return HikeUtilsModule.shareScreenWithLink(isInternalShare, backLinkData);
  }

  static shareScreen(isInternalShare) {
    return HikeUtilsModule.shareScreen(isInternalShare);
  }

  /**
   * Download and open micro app.
   * React Bridge Version 2
   *
   * @param mAppId     the m app id
   * @param params     the params
   * @param dpAssetUrl the dp asset url
   * @param mappTitle  the mapp title
   *
   */
  static downloadAndOpenReactMicroApp(mAppId, params, dpAssetUrl, mappTitle) {
    return HikeUtilsModule.downloadAndOpenReactMicroApp(mAppId, params, dpAssetUrl, mappTitle);
  }

  static doGet(key, params) {
    return HikeUtilsModule.doGet(key, params);
  }

  static doPost(key, params) {
    return HikeUtilsModule.doPost(key, params);
  }
  static logJSMessage(message) {
    HikeUtilsModule.logJSMessage(JSON.stringify(message));
  }
  static startContactChooserV2(data) {
    return HikeUtilsModule.startContactChooserV2(data);
  }
  static enableBot(msisdn, enable, increaseUnread) {
    return HikeUtilsModule.enableBot(msisdn, enable, increaseUnread);
  }
  static chooseFile(displayCameraItem) {
    return HikeUtilsModule.chooseFile(displayCameraItem);
  }
  static uploadFile(filePath, uploadUrl, doCompress) {
    var data = { 'filePath': filePath, 'uploadUrl': uploadUrl, 'doCompress': doCompress };
    return HikeUtilsModule.uploadFile(JSON.stringify(data));
  }
  /**
 * Subscribe to a Segment for a Hike service.
 * @param {Object} tagParams Tag Parameters
 * @param {number} tagParams.tag_type
 * @param {number} tagParams.tag_id

 * @returns {Promise} Promise is resolved/rejected based on whether subscription request is successful or not.
 */
  static doSubscribe(tagParams) { return HikeUtilsModule.doPost('SUBSCRIBE', tagParams); }

  /**
   * Unsubscribe from a Segment for a Hike service.
   * @param {Object} tagParams Tag Parameters
   * @param {number} tagParams.tag_type
   * @param {number} tagParams.tag_id
   * @returns {Promise} Promise is resolved/rejected based on whether un-subscription request is successful or not.
   */
  static doUnSubscribe(tagParams) { return HikeUtilsModule.doPost('UNSUBSCRIBE', tagParams); }


}

export default HikeUtils;
