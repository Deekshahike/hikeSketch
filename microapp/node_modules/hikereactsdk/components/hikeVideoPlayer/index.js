/**
 * Created by anurag on 04/10/16.
 */

import React, {Component} from 'react';
import VideoPlayer from './Video';
import {
  View,
  ActivityIndicator,
  StyleSheet,
  Text,
  TouchableOpacity,
  Image,
  Slider,
} from 'react-native';

const PropTypes = React.PropTypes;

const zeroPad = (number) => {
  if (number >= 10) {
    return `${number}`;
  } else {
    return `0${number}`;
  }
};

const playDurationFormatter = (durationInSeconds) => {
  let minutes = Math.floor(durationInSeconds / 60);
  let seconds = durationInSeconds - minutes * 60;

  return `${zeroPad(minutes)}:${zeroPad(seconds)}`;
};

export default class WrappedVideoPlayer extends Component {
  constructor(props) {
    super(props);

    this.state = {
      muted: this.props.muted,
      manuallyPaused: null,
      manuallyMuted: null,
      playedDuration: 0,
      playableDuration: 0,
      sliderValue: 0,
    };

    this._onLoad = this._onLoad.bind(this);
    this._onProgress = this._onProgress.bind(this);
    this._togglePause = this._togglePause.bind(this);
    this._toggleMute = this._toggleMute.bind(this);
    this._isPaused = this._isPaused.bind(this);
    this._isMuted = this._isMuted.bind(this);
    this._closeVideo = this._closeVideo.bind(this);
    this._onVideoError = this._onVideoError.bind(this);
    this._onEnd = this._onEnd.bind(this);
    this.seek = this.seek.bind(this);
  }

  _onLoad(videoObj) {
    this.setState({
      playableDuration: Math.floor(videoObj.duration),
    });

    this.props.onLoad && this.props.onLoad(videoObj);
  }

  _onEnd() {
    console.log('hvp on end');
    const isRepeatEnabled = !!this.props.repeat;

    if (!isRepeatEnabled && this.props.controls) {
      this.setState({
        manuallyPaused: true,
        sliderValue: 0,
      });

      this._seek(0, true);
    }

    this.props.onEnd && this.props.onEnd();
  }

  _onVideoError(err) {
    this.props.onError && this.props.onError(err);
  }

  _onProgress(videoObj) {
    const playedDuration = Math.floor(videoObj.currentTime);

    this.setState({
      playedDuration,
      sliderValue: playedDuration / this.state.playableDuration,
    });

    this.props.onProgress && this.props.onProgress(videoObj);
  }

  _isPaused() {
    let isPaused;

    if (this.state.manuallyPaused !== null) { // Pause was set atleast once using controls
      isPaused = this.state.manuallyPaused;
    } else {
      isPaused = this.props.paused === undefined ? false : this.props.paused;
    }

    return isPaused;
  }

  _isMuted() {
    let isMuted;

    if (this.state.manuallyMuted !== null) { // Mute was set atleast once using controls
      isMuted = this.state.manuallyMuted;
    } else {
      isMuted = this.props.muted === undefined ? false : this.props.muted;
    }

    return isMuted;
  }

  _togglePause() {
    let wasPaused, isPaused;

    if (this.state.manuallyPaused !== null) { // Pause was set atleast once using controls
      wasPaused = this.state.manuallyPaused;
    } else {
      wasPaused = this.props.paused === undefined ? false : this.props.paused;
    }

    isPaused = !wasPaused;

    this.setState({
      manuallyPaused: isPaused,
    });

    this.props.onTogglePause && this.props.onTogglePause(isPaused);
  }

  _toggleMute() {
    let wasMuted, isMuted;

    if (this.state.manuallyMuted !== null) { // Mute was set atleast once using controls
      wasMuted = this.state.manuallyMuted;
    } else {
      wasMuted = this.props.muted === undefined ? false : this.props.muted
    }

    isMuted = !wasMuted;

    this.setState({
      manuallyMuted: isMuted,
    });

    this.props.onToggleMute && this.props.onToggleMute(isMuted);
  }

  _closeVideo() {
    this.props.onTapClose && this.props.onTapClose();
  }

  _seek(value, isInternal) {
    const newSeekPosition = value * this.state.playableDuration;

    if (value <= 1) {
      this.videoPlayer.seek(value * this.state.playableDuration);

      if (!isInternal) { // Don't invoke onSeek callback in case of internal seek logic.
        this.props.onSeek && this.props.onSeek(newSeekPosition);
      }
    } else {
      throw new Error('seek requires a fraction/percentage value');
    }
  }

  seek(value) {
    this._seek(value);
  }

  _renderControls() {
    return <View style={styles.playerControlsCtr}>
      <View style={[styles.playerControls, styles.playerControlsTop]}>
        <TouchableOpacity onPress={this._closeVideo}>
          <Image style={styles.playerControl} source={require('./images/ic_close.png')}/>
        </TouchableOpacity>
        <TouchableOpacity onPress={this._toggleMute}>
          <Image style={styles.playerControl}
                 source={this._isMuted() ? require('./images/ic_soundoff.png') : require('./images/ic_soundon.png')}/>
        </TouchableOpacity>
      </View>
      <View style={[styles.playerControls, styles.playerControlsBottom]}>
        <TouchableOpacity onPress={this._togglePause}>
          <Image style={styles.playerControl}
                 source={this._isPaused() ? require('./images/ic_play.png') : require('./images/ic_pause.png')}/>
        </TouchableOpacity>
        <View style={styles.seekBar}>
          <Slider value={this.state.sliderValue} onSlidingComplete={this.seek}/>
        </View>
        <View style={styles.playProgress}>
          <Text
            style={styles.playProgressText}>{playDurationFormatter(this.state.playedDuration)}/{playDurationFormatter(this.state.playableDuration)}</Text>
        </View>
      </View>
    </View>;
  }

  render() {
    const videoView = <VideoPlayer {...this.props}
      ref={(videoPlayer) => { this.videoPlayer = videoPlayer; }} style={styles.videoPlayer}
      muted={this._isMuted()}                // Mutes the audio entirely.
      paused={this._isPaused()}
      onLoad={this._onLoad}    // Callback when video loads
      onProgress={this._onProgress}    // Callback every ~250ms with currentTime
      onEnd={this._onEnd}
    />;

    return (
      <View style={this.props.style}>
        {videoView}
        {this.props.controls ? this._renderControls() : null}
      </View>
    );
  }
}

WrappedVideoPlayer.propTypes = {
  source: PropTypes.oneOfType([
    PropTypes.shape({
      uri: PropTypes.string.isRequired,
      enableCache: PropTypes.bool
    }),
    // Opaque type returned by require('./video.mp4')
    PropTypes.number
  ]),
  repeat: PropTypes.bool,
  controls: PropTypes.bool,
  resizeMode: PropTypes.string,
  paused: PropTypes.bool,
  muted: PropTypes.bool,
  volume: PropTypes.number,
  onLoadStart: PropTypes.func,
  onLoad: PropTypes.func,
  onError: PropTypes.func,
  onProgress: PropTypes.func,
  onSeek: PropTypes.func,
  onEnd: PropTypes.func,
  onReadyForDisplay: PropTypes.func,
  onPlaybackStalled: PropTypes.func,
  onPlaybackResume: PropTypes.func,
  onTogglePause: PropTypes.func,
  onToggleMute: PropTypes.func,
  onTapClose: PropTypes.func,
};

WrappedVideoPlayer.defaultProps = {
  controls: false, // Show controls by default
  resizeMode: 'stretch',
  volume: 1,
};

const styles = StyleSheet.create({
  videoPlayer: {
    flex: 1,
    backgroundColor: '#ccc',
    justifyContent: 'center',
    alignItems: 'center',
  },
  playerControlsCtr: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
  },
  seekBar: {
    flex: 1,
    marginLeft: 20,
    marginRight: 20,
  },
  playerControls: {
    position: 'absolute',
    left: 20,
    right: 20,
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  playerControlsTop: {
    top: 30,
  },
  playerControlsBottom: {
    bottom: 30
  },
  playerControl: {
    width: 30,
    height: 30,
  },
  playProgress: {
    backgroundColor: 'transparent',
  },
  playProgressText: {
    color: '#fff',
    fontSize: 10,
  }
});